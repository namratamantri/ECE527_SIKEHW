// ==============================================================
// RTL generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
// Version: 2019.1
// Copyright (C) 1986-2019 Xilinx, Inc. All Rights Reserved.
// 
// ===========================================================

#ifndef _koa_mult_h_1_HH_
#define _koa_mult_h_1_HH_

#include "systemc.h"
#include "AESL_pkg.h"

#include "bc1_mult_1.h"
#include "bc1_mult.h"
#include "bc1_mult1.h"
#include "mp_mul_add_448ns_fYi.h"

namespace ap_rtl {

struct koa_mult_h_1 : public sc_module {
    // Port declarations 8
    sc_in_clk ap_clk;
    sc_in< sc_logic > ap_rst;
    sc_in< sc_logic > ap_start;
    sc_out< sc_logic > ap_done;
    sc_out< sc_logic > ap_idle;
    sc_out< sc_logic > ap_ready;
    sc_in< sc_lv<224> > a_V;
    sc_out< sc_lv<448> > ap_return;
    sc_signal< sc_logic > ap_var_for_const0;


    // Module declarations
    koa_mult_h_1(sc_module_name name);
    SC_HAS_PROCESS(koa_mult_h_1);

    ~koa_mult_h_1();

    sc_trace_file* mVcdFile;

    bc1_mult_1* grp_bc1_mult_1_fu_30;
    bc1_mult* grp_bc1_mult_fu_35;
    bc1_mult1* grp_bc1_mult1_fu_40;
    mp_mul_add_448ns_fYi<1,2,448,448,448>* mp_mul_add_448ns_fYi_U41;
    mp_mul_add_448ns_fYi<1,2,448,448,448>* mp_mul_add_448ns_fYi_U42;
    sc_signal< sc_lv<6> > ap_CS_fsm;
    sc_signal< sc_logic > ap_CS_fsm_state1;
    sc_signal< sc_lv<112> > ah_V_fu_45_p4;
    sc_signal< sc_lv<112> > ah_V_reg_129;
    sc_signal< sc_lv<112> > al_V_fu_56_p1;
    sc_signal< sc_lv<112> > al_V_reg_134;
    sc_signal< sc_lv<113> > ahl_V_fu_69_p2;
    sc_signal< sc_lv<113> > ahl_V_reg_139;
    sc_signal< sc_lv<224> > grp_bc1_mult_fu_35_ap_return;
    sc_signal< sc_lv<224> > a0_V_reg_144;
    sc_signal< sc_logic > ap_CS_fsm_state2;
    sc_signal< sc_logic > grp_bc1_mult_fu_35_ap_ready;
    sc_signal< sc_logic > grp_bc1_mult_fu_35_ap_done;
    sc_signal< sc_logic > grp_bc1_mult1_fu_40_ap_ready;
    sc_signal< sc_logic > grp_bc1_mult1_fu_40_ap_done;
    sc_signal< sc_logic > grp_bc1_mult_1_fu_30_ap_ready;
    sc_signal< sc_logic > grp_bc1_mult_1_fu_30_ap_done;
    sc_signal< bool > ap_block_state2_on_subcall_done;
    sc_signal< sc_lv<224> > grp_bc1_mult1_fu_40_ap_return;
    sc_signal< sc_lv<224> > a2_V_reg_150;
    sc_signal< sc_lv<226> > grp_bc1_mult_1_fu_30_ap_return;
    sc_signal< sc_lv<226> > a1_V_reg_156;
    sc_signal< sc_lv<227> > ret_V_fu_82_p2;
    sc_signal< sc_lv<227> > ret_V_reg_161;
    sc_signal< sc_logic > ap_CS_fsm_state3;
    sc_signal< sc_logic > ap_CS_fsm_state4;
    sc_signal< sc_lv<227> > ret_V_6_fu_98_p2;
    sc_signal< sc_lv<227> > ret_V_6_reg_171;
    sc_signal< sc_logic > ap_CS_fsm_state5;
    sc_signal< sc_lv<448> > grp_fu_106_p2;
    sc_signal< sc_logic > grp_bc1_mult_1_fu_30_ap_start;
    sc_signal< sc_logic > grp_bc1_mult_1_fu_30_ap_idle;
    sc_signal< sc_logic > grp_bc1_mult_fu_35_ap_start;
    sc_signal< sc_logic > grp_bc1_mult_fu_35_ap_idle;
    sc_signal< sc_logic > grp_bc1_mult1_fu_40_ap_start;
    sc_signal< sc_logic > grp_bc1_mult1_fu_40_ap_idle;
    sc_signal< sc_logic > grp_bc1_mult_1_fu_30_ap_start_reg;
    sc_signal< sc_logic > grp_bc1_mult_fu_35_ap_start_reg;
    sc_signal< sc_logic > grp_bc1_mult1_fu_40_ap_start_reg;
    sc_signal< sc_lv<113> > sext_ln68_1_fu_65_p1;
    sc_signal< sc_lv<113> > sext_ln68_fu_61_p1;
    sc_signal< sc_lv<227> > lhs_V_fu_76_p1;
    sc_signal< sc_lv<227> > rhs_V_fu_79_p1;
    sc_signal< sc_lv<227> > sext_ln215_fu_95_p1;
    sc_signal< sc_lv<448> > grp_fu_106_p0;
    sc_signal< sc_lv<448> > grp_fu_106_p1;
    sc_signal< sc_lv<339> > r_V_5_fu_112_p3;
    sc_signal< sc_lv<448> > grp_fu_123_p1;
    sc_signal< sc_lv<448> > grp_fu_123_p2;
    sc_signal< sc_lv<448> > ap_return_preg;
    sc_signal< sc_logic > ap_CS_fsm_state6;
    sc_signal< sc_lv<6> > ap_NS_fsm;
    static const sc_logic ap_const_logic_1;
    static const sc_logic ap_const_logic_0;
    static const sc_lv<6> ap_ST_fsm_state1;
    static const sc_lv<6> ap_ST_fsm_state2;
    static const sc_lv<6> ap_ST_fsm_state3;
    static const sc_lv<6> ap_ST_fsm_state4;
    static const sc_lv<6> ap_ST_fsm_state5;
    static const sc_lv<6> ap_ST_fsm_state6;
    static const sc_lv<32> ap_const_lv32_0;
    static const sc_lv<32> ap_const_lv32_1;
    static const bool ap_const_boolean_0;
    static const sc_lv<32> ap_const_lv32_2;
    static const sc_lv<32> ap_const_lv32_3;
    static const sc_lv<32> ap_const_lv32_4;
    static const sc_lv<32> ap_const_lv32_70;
    static const sc_lv<32> ap_const_lv32_DF;
    static const sc_lv<224> ap_const_lv224_lc_1;
    static const sc_lv<112> ap_const_lv112_0;
    static const sc_lv<448> ap_const_lv448_lc_1;
    static const sc_lv<32> ap_const_lv32_5;
    static const bool ap_const_boolean_1;
    // Thread declarations
    void thread_ap_var_for_const0();
    void thread_ap_clk_no_reset_();
    void thread_ah_V_fu_45_p4();
    void thread_ahl_V_fu_69_p2();
    void thread_al_V_fu_56_p1();
    void thread_ap_CS_fsm_state1();
    void thread_ap_CS_fsm_state2();
    void thread_ap_CS_fsm_state3();
    void thread_ap_CS_fsm_state4();
    void thread_ap_CS_fsm_state5();
    void thread_ap_CS_fsm_state6();
    void thread_ap_block_state2_on_subcall_done();
    void thread_ap_done();
    void thread_ap_idle();
    void thread_ap_ready();
    void thread_ap_return();
    void thread_grp_bc1_mult1_fu_40_ap_start();
    void thread_grp_bc1_mult_1_fu_30_ap_start();
    void thread_grp_bc1_mult_fu_35_ap_start();
    void thread_grp_fu_106_p0();
    void thread_grp_fu_106_p1();
    void thread_grp_fu_123_p1();
    void thread_lhs_V_fu_76_p1();
    void thread_r_V_5_fu_112_p3();
    void thread_ret_V_6_fu_98_p2();
    void thread_ret_V_fu_82_p2();
    void thread_rhs_V_fu_79_p1();
    void thread_sext_ln215_fu_95_p1();
    void thread_sext_ln68_1_fu_65_p1();
    void thread_sext_ln68_fu_61_p1();
    void thread_ap_NS_fsm();
};

}

using namespace ap_rtl;

#endif
